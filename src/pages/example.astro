---
import { Image } from "astro:assets";
import BaseLayout from "@/layouts/BaseLayout.astro";
// Array of image paths from hero_01 to hero_31
const heroImages = Array.from(
  { length: 31 },
  (_, index) =>
    `/screenshots/hero_${String(index + 1).padStart(2, "0")}.astro.png`
);
---
<!--
// Esto es un placeholder para la idea
//
// Necesitamos meter que los screenshots se metan en el src/screenshots
// para poder utilizar el <Image> de astro y que las imagences se optimizen.
//
// La idea es que el usuario cliquea en la image y les lleve exactamente a esa imagen independientemente de donde el bloque este.
<Image
class="object-bottom object-cover border rounded-lg group-hover:ring-2 group-hover:ring-offset-2 group-hover:ring-base-200 duration-300"
alt="dcdcdc"
src={heroOne}
/>
-->
<BaseLayout>
  <section>
     <div class="max-w-5xl pt-12 lg:pt-32 2xl:max-w-[100rem] mx-auto px-8">
          <h1
            class="text-4xl font-semibold tracking-tight text-black lg:text-balance 2xl:text-6xl">
            Heros
          </h1>
     </div>
      <div class="max-w-screen 2xl:max-w-[100rem] mx-auto px-8 mt-12">
      <div
        id="masonry-grid"
        class="gap-4 mt-12">
        {
          heroImages.map((imagePath, index) => (
            <a
              href="#_"
              class="group inline-block w-full relative">
              <div class="absolute top-1 left-2 -mt-4 z-10">
  <div class="bg-white text-black rounded-full p-2 border size-6 items-center flex justify-center text-xs"> <!-- Added a border for visibility -->
    {index + 1}
  </div>
</div>
              <img
                src={imagePath}
                class="w-full object-cover border rounded-lg group-hover:ring-2 group-hover:ring-offset-2 group-hover:ring-base-200 duration-300  relative"
                alt=""
                loading="lazy"
              />
            </a>
          ))
        }
      </div>
    </div>
  </section>
</BaseLayout>
<script type="module">
 const masonryGrid = document.getElementById("masonry-grid");
const columnWidth = 300; // Adjust this value as needed
const gap = 18; // Adjust this value to change the gap (in pixels)
function createMasonryGrid() {
  const gridWidth = masonryGrid.offsetWidth;
  const columns = Math.floor(gridWidth / columnWidth) || 1;
  // Reset the grid layout
  masonryGrid.style.columnCount = columns.toString();
  masonryGrid.style.columnGap = `${gap}px`;
  // Remove any existing grid styles
  masonryGrid.style.display = 'block';
  masonryGrid.style.gridTemplateColumns = '';
  masonryGrid.style.gridTemplateRows = '';
  const items = Array.from(masonryGrid.children);
  items.forEach((item) => {
    // Reset item styles
    item.style.gridRowStart = '';
    item.style.gridColumnStart = '';
    // Add styles for masonry layout
    item.style.breakInside = 'avoid';
    item.style.marginBottom = `${gap}px`; // Set the vertical gap between items
  });
}
// Initial layout
createMasonryGrid();
// Update layout on window resize
window.addEventListener("resize", createMasonryGrid);
// Update layout when all images are loaded
window.addEventListener("load", createMasonryGrid);
// Optional: Update layout when new images are added
const observer = new MutationObserver(createMasonryGrid);
observer.observe(masonryGrid, { childList: true, subtree: true });
</script>
