---
// Foundation
import BaseLayout from "@/layouts/BaseLayout.astro";
import Text from "@/components/fundations/typography/Text.astro";
import Playground from "@/components/playground/Playground.astro";
import Wrapper from "@/components/fundations/containers/Wrapper.astro";
import IconButton from "@/components/fundations/buttons/IconButton.astro";
import ChevronLeft from "@/components/fundations/icons/ChevronLeft.astro";
import ChevronRight from "@/components/fundations/icons/ChevronRight.astro";
// import DetailToolbarIsland from "@/components/playground/DetailToolbarIsland";

// Parameters
const { section, subsection, index } = Astro.params;
const modules = import.meta.glob("@/components/oxbow/**/*.astro");
const keys = Object.keys(modules);
const sectionRegex = new RegExp(`${section}/${subsection}/.+\\.astro$`, "i");
const sectionKeys = keys.filter((k) => k.match(sectionRegex));
sectionKeys.sort();
const currentKey = sectionKeys[parseInt(index) - 1];
const componentModule = currentKey ? await modules[currentKey]() : undefined;

// Metadata from module exports
const componentDescription = componentModule?.description || "";
const freeComponent = componentModule?.freeComponent || false;

const sectionLength = sectionKeys.length;
const PreviewElement = parseInt(index) === 1 ? "div" : "a";
const PreviewElementProps =
  parseInt(index) === 1
    ? {}
    : { href: `/playground/${section}/${subsection}/${parseInt(index) - 1}` };
const NextElement = parseInt(index) === sectionLength ? "div" : "a";
const NextElementProps =
  parseInt(index) === sectionLength
    ? {}
    : { href: `/playground/${section}/${subsection}/${parseInt(index) + 1}` };

// Build category â†’ blocks map and counts for detail navigation
const triples = keys.map((k) => k.split("/").slice(-3)); // [section, subsection, file]
const subsByCat = Object.fromEntries(
  Array.from(new Set(triples.map(([sec]) => sec))).map((sec) => {
    const subs = Array.from(
      new Set(triples.filter(([s]) => s === sec).map(([, sub]) => sub)),
    ).sort();
    return [sec, subs];
  }),
);
const countsByCatSub = triples.reduce(
  (acc, [sec, sub]) => {
    const key = `${sec}/${sub}`;
    acc[key] = (acc[key] || 0) + 1;
    return acc;
  },
  {} as Record<string, number>,
);
---

<style is:global>
  html {
    overflow-y: auto;
    scrollbar-gutter: stable;
  }

  :where(html, body) {
    margin: 0;
    padding: 0;
    min-height: 0 !important;
    height: auto !important;
  }
  #oxbow-root {
    display: block;
  }
  #oxbow-root img {
    max-width: 100%;
    height: auto;
  }
</style>

<BaseLayout hideFooter={true}>
  <section class="border-t border-zinc-200 dark:border-zinc-800 relative">
    <Wrapper variant="standard" class="lg:border-x lg:border-zinc-200">
      <div class="flex items-end justify-between w-full">
        <div class="flex flex-wrap items-center gap-2">
          <div class="flex items-center gap-2">
            <button
              class="flex items-center text-sm gap-2 text-zinc-500 hover:text-zinc-900"
              onclick="history.back();"
            >
              <ChevronLeft size="sm" slot="icon" />
              Go back</button
            >
            <span aria-hidden="true" class="text-zinc-500">/</span>
            <Text
              tag="h1"
              variant="textSM"
              class="font-medium capitalize text-zinc-900"
            >
              {`${subsection.replace(/-/g, " ")} #${index.replace(/-/g, " ")}`}
            </Text>
          </div>
          <span aria-hidden="true" class="hidden text-zinc-500 md:block">/</span
          >
          <Text tag="p" variant="textSM" class="text-zinc-500">
            {componentDescription}
          </Text>
        </div>
        <!-- Toolbar moved into Playground toolbar -->
      </div>
    </Wrapper>
  </section>
  <section class="border-t border-zinc-200 relative">
    <Wrapper
      variant="wide"
      class="py-8 2xl:border-x 2xl:border-zinc-200 dark:2xl:border-zinc-800 relative"
    >
      <Playground
        componentIndex={parseInt(index)}
        componentPath={currentKey ? currentKey.replace(/^\//, "") : ""}
        playgroundRef={`${section}-${subsection}-${index}`}
        freeComponent={freeComponent}
        initialTabIsCode={Astro.url.searchParams.get("tab") === "code"}
        navCat={section}
        navSub={subsection}
        navIdx={parseInt(index)}
        subsByCat={subsByCat}
        counts={countsByCatSub}
        prevHref={parseInt(index) === 1
          ? undefined
          : `/playground/${section}/${subsection}/${parseInt(index) - 1}`}
        nextHref={parseInt(index) === sectionLength
          ? undefined
          : `/playground/${section}/${subsection}/${parseInt(index) + 1}`}
        sectionLength={sectionLength}
      >
        <componentModule.default />
      </Playground>
    </Wrapper>
  </section>
</BaseLayout>

<script is:inline>
  (function () {
    const params = new URLSearchParams(location.search);
    const iframeId = params.get("iframeId") || "iframe-unknown";

    const send = () => {
      // Use a robust doc height calculation
      const b = document.body;
      const d = document.documentElement;
      const height = Math.max(
        b.scrollHeight,
        d.scrollHeight,
        b.offsetHeight,
        d.offsetHeight,
        b.clientHeight,
        d.clientHeight,
      );
      parent.postMessage(
        { type: "oxbow-iframe-height", id: iframeId, height },
        "*",
      );
    };

    // 1) On full load
    window.addEventListener("load", send);

    // 2) When parent asks
    window.addEventListener("message", (e) => {
      if (e.data && e.data.type === "oxbow-iframe-resize-request") send();
    });

    // 3) Watch DOM & layout changes
    const ro = new ResizeObserver(() => send());
    ro.observe(document.documentElement);
    ro.observe(document.body);

    // 4) Late-loading media
    document.querySelectorAll("img, video, iframe").forEach((el) => {
      if ("complete" in el && el.complete) return;
      el.addEventListener("load", send, { once: true });
      el.addEventListener("error", send, { once: true });
    });

    // 5) Short bootstrap polling for very dynamic UIs
    let n = 0;
    const iv = setInterval(() => {
      send();
      if (++n > 20) clearInterval(iv); // ~1s if 50ms
    }, 50);
  })();
</script>

<script is:inline>
  // Same-origin direct resize loop: mirrors iframe document height into iframe and wrapper
  (function () {
    function computeHeight(doc) {
      try {
        const b = doc.body;
        const e = doc.documentElement;
        return Math.max(
          b?.scrollHeight || 0,
          e?.scrollHeight || 0,
          b?.offsetHeight || 0,
          e?.offsetHeight || 0,
          b?.clientHeight || 0,
          e?.clientHeight || 0,
        );
      } catch (_) {
        return 0;
      }
    }

    function tick() {
      document
        .querySelectorAll('section[x-data="playground"] iframe')
        .forEach((ifr) => {
          try {
            const doc = ifr.contentDocument || ifr.contentWindow?.document;
            if (!doc) return;
            const h = Math.max(200, computeHeight(doc));
            const target = h + "px";
            if (ifr.style.height !== target) {
              ifr.style.height = target;
            }
            const container = ifr.parentElement;
            if (container && container.style.height !== target) {
              container.style.height = target;
            }
          } catch (_) {}
        });
      requestAnimationFrame(tick);
    }

    if (document.readyState === "loading") {
      document.addEventListener(
        "DOMContentLoaded",
        () => requestAnimationFrame(tick),
        { once: true },
      );
    } else {
      requestAnimationFrame(tick);
    }
  })();
</script>
