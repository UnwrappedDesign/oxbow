import{existsSync as v}from"node:fs";import{rmdir as O,readFile as p,writeFile as w,mkdir as x}from"node:fs/promises";import{fileURLToPath as R}from"node:url";import{brotliCompressSync as C,gzipSync as T}from"node:zlib";import{Table as k}from"console-table-printer";import A from"md5";import u from"pretty-bytes";import*as $ from"@babel/parser";import _ from"@babel/traverse";import E from"@babel/generator";const M=_.default,z=E.default;import{defaultOptions as b}from"./options.js";import{calculatePercent as I,escapeRegExp as S,walkFiles as f,MAPS_DIRECTORY as i,getViteConfiguration as j}from"./utils.js";function L(d){const c={...b,...d,rename:{...b.rename,...d?.rename,outputMapCallback:async o=>{const r=JSON.stringify(o);try{v(i)||await x(i)}catch(e){console.error(`\x1B[31mTemporal directory to process files couldn't be created: ${e}.\x1B[39m`);return}try{await w(`${i}/class-map-${A(r)}.json`,r,{encoding:"utf8",flag:"w"})}catch(e){console.error(`\x1B[31mThere was an error saving the CSS map: ${e}.\x1B[39m`);return}d?.rename?.outputMapCallback?.(o)}}};return{name:"astro-rename",hooks:{"astro:config:setup":async({config:o,updateConfig:r,command:e})=>{if(e==="build"){try{await O(i,{recursive:!0})}catch{}r({vite:await j(c?.rename,o.vite)})}},"astro:build:done":async({dir:o})=>{const r=R(o);let e={};try{for await(const s of f(i)){const a=await p(s,"utf8");e={...e,...JSON.parse(a)}}}catch{console.error("\x1B[31mA CSS map of transformed classes it isn't provided\x1B[39m");return}try{const s=new k;for await(const a of f(r)){if(!c.targetExt.some(m=>a.endsWith(m)))continue;const g=a.replace(r,"");let t=await p(a,"utf-8");const n=t.length;Object.keys(e).forEach(m=>{const h=new RegExp(c.matchClasses(S(m)).replaceAll("&","&#x26;"),"g");t=t.replaceAll(h,`$1${e[m]}`)}),await w(a,t,{encoding:"utf8",flag:"w"});const l=t.length,y=I(n,l);s.addRow({File:g,"Original Size":u(n),"New Size":u(l),Reduced:`${y}%`,Gzip:u(T(t).byteLength),Brotli:u(C(t).byteLength)})}s.printTable()}catch{console.error("\x1B[31mThe build directory doesn't exists.\x1B[39m");return}},"astro:build:ssr":async()=>{let o={};try{for await(const r of f(i)){const e=await p(r,"utf8");o={...o,...JSON.parse(e)}}}catch{console.error("\x1B[31mA CSS map of transformed classes it isn't provided\x1B[39m");return}for await(const r of f("./dist/server"))if(c.targetExt.some(e=>r.endsWith(e))){console.log("Processing file",r);try{const e=await p(r,"utf-8"),s=$.parse(e,{sourceType:"module",plugins:["jsx"]}),a=t=>Object.keys(o).reduce((n,l)=>{const y=new RegExp(c.matchClasses(S(l)).replaceAll("&","&#x26;"),"g");return n.replaceAll(y,`$1${o[l]}`)},t);M(s,{StringLiteral(t){t.node.value=a(t.node.value)},JSXText(t){t.node.value=a(t.node.value)},TemplateLiteral(t){t.node.quasis.map(n=>{n.value.raw=a(n.value.raw),n.value.cooked=a(n.value.cooked??"")})}});const g=z(s,{},e);await w(r,g.code,{encoding:"utf8",flag:"w"})}catch(e){console.log(e)}}}}}}export{L as default};
